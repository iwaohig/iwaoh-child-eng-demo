AWSTemplateFormatVersion: '2010-09-09'
Description: 'Child English Demo Application - DynamoDB, Lambda, and API Gateway'

Parameters:
  EnvironmentName:
    Description: Environment name prefix for resources
    Type: String
    Default: 'iwaoh-child-eng'
  
  CorsOrigin:
    Description: CORS origin for the API
    Type: String
    Default: '*'
  
  BotAccessToken:
    Type: String
    NoEcho: true
    Description: 'LINE WORKS Bot Access Token'
    Default: 'jp1AAABNRigQwXkQBKd8RGaRyN5dxvnY+5XUO4Dbb7MBM7myIPvlXCT8U6E0+CIOiW5PesWVfkgFq2Pblzl6YmpauOnbImX2oSWHxpcYGZQQOhXwOhaa9jFOlAkQZeQBMNM7MIMHiFSzMs5Ekqr/MMOwf0k9+u8ADZ5tpiJM9Y2Cl834njfiKvKkMlD9DhH7UQfVago7OZp+XY3y1lhiMNmbYQT2n1f7Z0wF+lvbSVMJ4m1fR4A67EDhzy6/NsPM5hea11+nGhZ01DVJ6sll1ZWPvMcXYSuYGxY/MkRDuWtr+SAhKGzgvQEIjbi2WPx+SP3T/XG2MELCd5cA8D6e2d/L67FzRQEqmSPUBkJipmbJQ06tjiy+udlRGravDLGflDj5iNQDLUz5tWGVSCcbH31cOIw5Hf/q/86k5TVn/CCwKNO0eDh.kwiu9yNovfcs8Rumz2QSOg'
  
  BotRefreshToken:
    Type: String
    NoEcho: true
    Description: 'LINE WORKS Bot Refresh Token'
    Default: 'jp1AAAAhOu6veazZ218mv01Dok0spum3ZNtpJd/KQ6+AFfdsUfkQYEbr/UZPUPlMl6+RUCeA2baqKKJPZI/HYOBwfLMeg9BFidZazj7SaTOaT2GlgASoxKljVwgU7zm15a47op4JB/6bv1zAP2DPYS4WNfpC+FlPO2WWL/nalIH2TtePb3SaB58QkAUemgGgZS/t/IE5A==.kwiu9yNovfcs8Rumz2QSOg'
  
  BotClientId:
    Type: String
    NoEcho: true
    Description: 'LINE WORKS Bot Client ID'
    Default: 'zC3oMwjuE5nbtWwAkPkk'
  
  BotClientSecret:
    Type: String
    NoEcho: true
    Description: 'LINE WORKS Bot Client Secret'
    Default: '0OldwPrBU_'
  
  BotChannelId:
    Type: String
    NoEcho: true
    Description: 'LINE WORKS Bot Channel ID (Talk Room ID)'
    Default: '05a3d91c-c172-893a-e6d3-3bd1e0ce1920'

Resources:
  # DynamoDB Table for Applications
  ApplicationsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${EnvironmentName}-applications'
      BillingMode: PAY_PER_REQUEST
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
        - AttributeName: classroom
          AttributeType: S
        - AttributeName: status
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: TimestampIndex
          KeySchema:
            - AttributeName: timestamp
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        - IndexName: ClassroomIndex
          KeySchema:
            - AttributeName: classroom
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: StatusIndex
          KeySchema:
            - AttributeName: status
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: ChildEnglishDemo

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${EnvironmentName}-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt ApplicationsTable.Arn
                  - !Sub '${ApplicationsTable.Arn}/index/*'
              - Effect: Allow
                Action:
                  - dynamodb:DescribeStream
                  - dynamodb:GetRecords
                  - dynamodb:GetShardIterator
                  - dynamodb:ListStreams
                Resource:
                  - !GetAtt ApplicationsTable.StreamArn

  # Lambda Function for Form Submission
  FormSubmissionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${EnvironmentName}-form-submission'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          APPLICATIONS_TABLE: !Ref ApplicationsTable
          CORS_ORIGIN: !Ref CorsOrigin
      Code:
        ZipFile: |
          const { DynamoDBClient, PutItemCommand } = require('@aws-sdk/client-dynamodb');
          const { marshall } = require('@aws-sdk/util-dynamodb');
          const dynamodb = new DynamoDBClient({ region: process.env.AWS_REGION || 'ap-northeast-1' });

          exports.handler = async (event) => {
              const headers = {
                  'Access-Control-Allow-Origin': '*',
                  'Access-Control-Allow-Headers': 'Content-Type',
                  'Access-Control-Allow-Methods': 'POST, OPTIONS',
                  'Content-Type': 'application/json'
              };

              try {
                  if (event.httpMethod === 'OPTIONS') {
                      return {
                          statusCode: 200,
                          headers,
                          body: JSON.stringify({ message: 'OK' })
                      };
                  }

                  if (event.httpMethod === 'POST') {
                      const body = JSON.parse(event.body);
                      
                      const timestamp = new Date().toISOString();
                      const submissionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                      
                      const item = {
                          id: submissionId,
                          timestamp,
                          status: '確認',
                          classroom: body.classroom,
                          parentLastName: body.parentLastName,
                          parentFirstName: body.parentFirstName,
                          parentPhone: body.phone,
                          parentEmail: body.email,
                          childLastName: body.childLastName,
                          childFirstName: body.childFirstName,
                          childGender: body.gender,
                          childBirthYear: body.birthYear,
                          childBirthMonth: body.birthMonth,
                          childBirthDay: body.birthDay,
                          trigger: body.trigger,
                          message: body.message || '',
                          createdAt: timestamp,
                          updatedAt: timestamp
                      };
                      
                      const params = {
                          TableName: process.env.APPLICATIONS_TABLE,
                          Item: marshall(item, { removeUndefinedValues: true })
                      };
                      
                      await dynamodb.send(new PutItemCommand(params));
                      
                      return {
                          statusCode: 200,
                          headers,
                          body: JSON.stringify({
                              success: true,
                              message: 'Application submitted successfully',
                              id: submissionId,
                              timestamp: timestamp
                          })
                      };
                  }

                  return {
                      statusCode: 405,
                      headers,
                      body: JSON.stringify({ error: 'Method not allowed' })
                  };

              } catch (error) {
                  console.error('Error:', error);
                  return {
                      statusCode: 500,
                      headers,
                      body: JSON.stringify({
                          success: false,
                          error: 'Internal server error'
                      })
                  };
              }
          };
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: ChildEnglishDemo

  # Lambda Function for Admin API
  AdminApiLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${EnvironmentName}-admin-api'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          APPLICATIONS_TABLE: !Ref ApplicationsTable
          CORS_ORIGIN: !Ref CorsOrigin
      Code:
        ZipFile: |
          const { DynamoDBClient, ScanCommand, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
          const { marshall, unmarshall } = require('@aws-sdk/util-dynamodb');
          const dynamodb = new DynamoDBClient({ region: process.env.AWS_REGION || 'ap-northeast-1' });

          exports.handler = async (event) => {
              const headers = {
                  'Access-Control-Allow-Origin': '*',
                  'Access-Control-Allow-Headers': 'Content-Type',
                  'Access-Control-Allow-Methods': 'GET, PUT, OPTIONS',
                  'Content-Type': 'application/json'
              };
              
              console.log('DynamoDB scan params:', {
                  TableName: process.env.APPLICATIONS_TABLE
              });

              try {
                  if (event.httpMethod === 'OPTIONS') {
                      return {
                          statusCode: 200,
                          headers,
                          body: JSON.stringify({ message: 'OK' })
                      };
                  }

                  if (event.httpMethod === 'GET') {
                      const params = {
                          TableName: process.env.APPLICATIONS_TABLE
                      };
                      
                      console.log('DynamoDB scan params:', params);
                      const command = new ScanCommand(params);
                      const result = await dynamodb.send(command);
                      const rawItems = result.Items ? result.Items.map(item => unmarshall(item)) : [];
                      
                      // データ構造を統一（WOFF管理画面のexpected形式に変換）
                      const items = rawItems.map(item => {
                          // 既にネスト構造の場合はそのまま、フラット構造の場合は変換
                          if (item.child && item.parent) {
                              return item; // 既に正しい構造
                          }
                          
                          return {
                              ...item,
                              child: {
                                  lastName: item.childLastName || '',
                                  firstName: item.childFirstName || '',
                                  gender: item.childGender || '',
                                  birthYear: item.childBirthYear || '',
                                  birthMonth: item.childBirthMonth || '',
                                  birthDay: item.childBirthDay || ''
                              },
                              parent: {
                                  lastName: item.parentLastName || '',
                                  firstName: item.parentFirstName || '',
                                  email: item.parentEmail || '',
                                  phone: item.parentPhone || ''
                              }
                          };
                      });
                      
                      console.log('DynamoDB scan result:', { Count: result.Count, Items: items.length });
                      
                      return {
                          statusCode: 200,
                          headers,
                          body: JSON.stringify({
                              success: true,
                              data: items
                          })
                      };
                  }

                  if (event.httpMethod === 'PUT') {
                      const body = JSON.parse(event.body);
                      const id = event.pathParameters?.id;
                      
                      if (!id) {
                          return {
                              statusCode: 400,
                              headers,
                              body: JSON.stringify({ error: 'Missing id parameter' })
                          };
                      }
                      
                      // 動的にUpdateExpressionとAttributeValuesを構築
                      let updateExpression = 'SET #status = :status, updatedAt = :updatedAt';
                      const expressionAttributeNames = {
                          '#status': 'status'
                      };
                      const expressionAttributeValues = {
                          ':status': body.status,
                          ':updatedAt': new Date().toISOString()
                      };
                      
                      // 予約日時フィールドがある場合は追加
                      if (body.reservationDate) {
                          updateExpression += ', reservationDate = :reservationDate';
                          expressionAttributeValues[':reservationDate'] = body.reservationDate;
                      }
                      
                      if (body.reservationTime) {
                          updateExpression += ', reservationTime = :reservationTime';
                          expressionAttributeValues[':reservationTime'] = body.reservationTime;
                      }
                      
                      if (body.reservationNotes !== undefined) {
                          updateExpression += ', reservationNotes = :reservationNotes';
                          expressionAttributeValues[':reservationNotes'] = body.reservationNotes;
                      }
                      
                      // 体験記録フィールドがある場合は追加
                      if (body.experienceDate) {
                          updateExpression += ', experienceDate = :experienceDate';
                          expressionAttributeValues[':experienceDate'] = body.experienceDate;
                      }
                      
                      if (body.experienceTime) {
                          updateExpression += ', experienceTime = :experienceTime';
                          expressionAttributeValues[':experienceTime'] = body.experienceTime;
                      }
                      
                      if (body.experienceDetails) {
                          updateExpression += ', experienceDetails = :experienceDetails';
                          expressionAttributeValues[':experienceDetails'] = body.experienceDetails;
                      }
                      
                      if (body.experienceRating !== undefined) {
                          updateExpression += ', experienceRating = :experienceRating';
                          expressionAttributeValues[':experienceRating'] = body.experienceRating;
                      }
                      
                      if (body.experienceNotes !== undefined) {
                          updateExpression += ', experienceNotes = :experienceNotes';
                          expressionAttributeValues[':experienceNotes'] = body.experienceNotes;
                      }
                      
                      const params = {
                          TableName: process.env.APPLICATIONS_TABLE,
                          Key: marshall({ id }),
                          UpdateExpression: updateExpression,
                          ExpressionAttributeNames: expressionAttributeNames,
                          ExpressionAttributeValues: marshall(expressionAttributeValues)
                      };
                      
                      const updateCommand = new UpdateItemCommand(params);
                      await dynamodb.send(updateCommand);
                      
                      return {
                          statusCode: 200,
                          headers,
                          body: JSON.stringify({
                              success: true,
                              message: 'Status updated successfully'
                          })
                      };
                  }

                  return {
                      statusCode: 405,
                      headers,
                      body: JSON.stringify({ error: 'Method not allowed' })
                  };

              } catch (error) {
                  console.error('Error:', error);
                  return {
                      statusCode: 500,
                      headers,
                      body: JSON.stringify({
                          success: false,
                          error: 'Internal server error'
                      })
                  };
              }
          };
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: ChildEnglishDemo

  # Lambda Function for Bot Notifications
  BotNotificationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${EnvironmentName}-bot-notify'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 128
      ReservedConcurrentExecutions: 1
      Environment:
        Variables:
          BOT_ID: '10248294'
          CHANNEL_ID: !Ref BotChannelId
          ACCESS_TOKEN: !Ref BotAccessToken
          REFRESH_TOKEN: !Ref BotRefreshToken
          CLIENT_ID: !Ref BotClientId
          CLIENT_SECRET: !Ref BotClientSecret
      Code:
        ZipFile: |
          const https = require('https');
          
          const BOT_ID = process.env.BOT_ID;
          const CHANNEL_ID = process.env.CHANNEL_ID;
          let accessToken = process.env.ACCESS_TOKEN;
          const refreshToken = process.env.REFRESH_TOKEN;
          const clientId = process.env.CLIENT_ID;
          const clientSecret = process.env.CLIENT_SECRET;
          let tokenExpiresAt = Date.now() + 3600 * 1000;
          
          async function refreshAccessToken() {
              return new Promise((resolve, reject) => {
                  const data = `refresh_token=${encodeURIComponent(refreshToken)}&grant_type=refresh_token&client_id=${encodeURIComponent(clientId)}&client_secret=${encodeURIComponent(clientSecret)}`;
          
                  const options = {
                      hostname: 'auth.worksmobile.com',
                      path: '/oauth2/v2.0/token',
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/x-www-form-urlencoded',
                          'Content-Length': Buffer.byteLength(data)
                      }
                  };
          
                  const req = https.request(options, (res) => {
                      let responseData = '';
          
                      res.on('data', (chunk) => {
                          responseData += chunk;
                      });
          
                      res.on('end', () => {
                          if (res.statusCode === 200) {
                              const result = JSON.parse(responseData);
                              accessToken = result.access_token;
                              tokenExpiresAt = Date.now() + (result.expires_in * 1000);
                              console.log('Token refreshed successfully');
                              resolve(accessToken);
                          } else {
                              reject(new Error(`Token refresh failed: ${res.statusCode} - ${responseData}`));
                          }
                      });
                  });
          
                  req.on('error', (error) => {
                      reject(error);
                  });
          
                  req.write(data);
                  req.end();
              });
          }
          
          async function sendLinkMessage(applicationData, messageType = 'new') {
              const currentTime = Date.now();
              const timeUntilExpiry = tokenExpiresAt - currentTime;
              console.log(`Token check: current=${new Date(currentTime).toISOString()}, expires=${new Date(tokenExpiresAt).toISOString()}, timeLeft=${timeUntilExpiry}ms`);
              
              if (currentTime > tokenExpiresAt - 300000) {
                  console.log('Token is expiring soon, refreshing...');
                  try {
                      await refreshAccessToken();
                      console.log('Token refresh completed successfully');
                  } catch (error) {
                      console.error('Failed to refresh token:', error);
                      throw error;
                  }
              } else {
                  console.log('Token is still valid, no refresh needed');
              }
          
              let contentText = '';
              let linkText = '';
              
              if (messageType === 'new') {
                  contentText = `新しい体験申込がありました！\n\n申込者: ${applicationData.parent.lastName} ${applicationData.parent.firstName} 様\nお子様: ${applicationData.child.lastName} ${applicationData.child.firstName} さん\n教室: ${applicationData.classroom}\n\n詳細を確認してください。`;
                  linkText = '申込詳細を確認';
              } else if (messageType === 'status') {
                  let statusMessage = `申込ステータスが変更されました\n\n申込者: ${applicationData.parent.lastName} ${applicationData.parent.firstName} 様\nお子様: ${applicationData.child.lastName} ${applicationData.child.firstName} さん\n教室: ${applicationData.classroom}\n新しいステータス: ${applicationData.status}`;
                  
                  // 予約済みの場合は予約日時情報を追加
                  if (applicationData.status === '予約済み' && applicationData.reservationDate && applicationData.reservationTime) {
                      const reservationDate = new Date(applicationData.reservationDate);
                      const formattedDate = reservationDate.toLocaleDateString('ja-JP', {
                          year: 'numeric',
                          month: 'long',
                          day: 'numeric',
                          weekday: 'short'
                      });
                      statusMessage += `\n予約日時: ${formattedDate} ${applicationData.reservationTime}`;
                      
                      if (applicationData.reservationNotes) {
                          statusMessage += `\n備考: ${applicationData.reservationNotes}`;
                      }
                      linkText = '予約詳細を確認';
                  } else if (applicationData.status === '体験済み' && applicationData.experienceDate && applicationData.experienceTime) {
                      const experienceDate = new Date(applicationData.experienceDate);
                      const formattedDate = experienceDate.toLocaleDateString('ja-JP', {
                          year: 'numeric',
                          month: 'long',
                          day: 'numeric',
                          weekday: 'short'
                      });
                      statusMessage += `\n体験日時: ${formattedDate} ${applicationData.experienceTime}`;
                      
                      if (applicationData.experienceDetails) {
                          const truncatedDetails = applicationData.experienceDetails.length > 50 
                              ? applicationData.experienceDetails.substring(0, 50) + '...'
                              : applicationData.experienceDetails;
                          statusMessage += `\n体験の様子: ${truncatedDetails}`;
                      }
                      
                      if (applicationData.experienceRating) {
                          statusMessage += `\n評価: ${applicationData.experienceRating}`;
                      }
                      linkText = '体験記録を確認';
                  } else {
                      linkText = 'ステータス確認';
                  }
                  
                  contentText = statusMessage + '\n\n詳細を確認してください。';
              }
          
              const message = {
                  content: {
                      type: 'link',
                      contentText: contentText,
                      linkText: linkText,
                      link: `https://woff.worksmobile.com/woff/Gwb_BTfV562bnUxhhp81PA/?view=detail&id=${applicationData.id}`
                  }
              };
          
              return new Promise((resolve, reject) => {
                  const data = JSON.stringify(message);
          
                  const options = {
                      hostname: 'www.worksapis.com',
                      path: `/v1.0/bots/${BOT_ID}/channels/${encodeURIComponent(CHANNEL_ID)}/messages`,
                      method: 'POST',
                      headers: {
                          'Authorization': `Bearer ${accessToken}`,
                          'Content-Type': 'application/json',
                          'Content-Length': Buffer.byteLength(data)
                      }
                  };
          
                  const req = https.request(options, (res) => {
                      let responseData = '';
          
                      res.on('data', (chunk) => {
                          responseData += chunk;
                      });
          
                      res.on('end', () => {
                          if (res.statusCode === 200 || res.statusCode === 201) {
                              console.log('Message sent successfully:', responseData);
                              try {
                                  resolve(responseData ? JSON.parse(responseData) : { success: true });
                              } catch (parseError) {
                                  console.log('Response parse warning:', parseError.message);
                                  resolve({ success: true, message: 'Message sent (empty response)' });
                              }
                          } else {
                              reject(new Error(`Failed to send message: ${res.statusCode} - ${responseData}`));
                          }
                      });
                  });
          
                  req.on('error', (error) => {
                      reject(error);
                  });
          
                  req.write(data);
                  req.end();
              });
          }
          
          exports.handler = async (event) => {
              console.log('Received event:', JSON.stringify(event, null, 2));
          
              try {
                  let applicationData;
                  
                  if (event.Records) {
                      for (const record of event.Records) {
                          console.log(`Processing ${record.eventName} event for record:`, record.dynamodb.Keys);
                          
                          if (record.eventName === 'INSERT') {
                              // 新規申込通知
                              applicationData = record.dynamodb.NewImage;
                              
                              applicationData = {
                                  id: applicationData.id.S,
                                  parent: {
                                      lastName: applicationData.parentLastName.S,
                                      firstName: applicationData.parentFirstName.S,
                                      email: applicationData.parentEmail.S,
                                      phone: applicationData.parentPhone.S
                                  },
                                  child: {
                                      lastName: applicationData.childLastName.S,
                                      firstName: applicationData.childFirstName.S,
                                      gender: applicationData.childGender.S,
                                      birthYear: applicationData.childBirthYear.S,
                                      birthMonth: applicationData.childBirthMonth.S,
                                      birthDay: applicationData.childBirthDay.S
                                  },
                                  classroom: applicationData.classroom.S,
                                  trigger: applicationData.trigger ? applicationData.trigger.S : '',
                                  message: applicationData.message ? applicationData.message.S : '',
                                  status: applicationData.status.S,
                                  timestamp: applicationData.timestamp.S
                              };
          
                              console.log('Sending new application notification');
                              await sendLinkMessage(applicationData, 'new');
                              
                          } else if (record.eventName === 'MODIFY') {
                              // ステータス変更通知
                              const oldImage = record.dynamodb.OldImage;
                              const newImage = record.dynamodb.NewImage;
                              
                              // ステータスが変更されたかチェック
                              const oldStatus = oldImage.status ? oldImage.status.S : '';
                              const newStatus = newImage.status ? newImage.status.S : '';
                              
                              if (oldStatus !== newStatus) {
                                  console.log(`Status changed from '${oldStatus}' to '${newStatus}'`);
                                  
                                  applicationData = {
                                      id: newImage.id.S,
                                      parent: {
                                          lastName: newImage.parentLastName.S,
                                          firstName: newImage.parentFirstName.S,
                                          email: newImage.parentEmail.S,
                                          phone: newImage.parentPhone.S
                                      },
                                      child: {
                                          lastName: newImage.childLastName.S,
                                          firstName: newImage.childFirstName.S,
                                          gender: newImage.childGender.S,
                                          birthYear: newImage.childBirthYear.S,
                                          birthMonth: newImage.childBirthMonth.S,
                                          birthDay: newImage.childBirthDay.S
                                      },
                                      classroom: newImage.classroom.S,
                                      trigger: newImage.trigger ? newImage.trigger.S : '',
                                      message: newImage.message ? newImage.message.S : '',
                                      status: newStatus,
                                      timestamp: newImage.timestamp.S,
                                      oldStatus: oldStatus,
                                      reservationDate: newImage.reservationDate ? newImage.reservationDate.S : '',
                                      reservationTime: newImage.reservationTime ? newImage.reservationTime.S : '',
                                      reservationNotes: newImage.reservationNotes ? newImage.reservationNotes.S : '',
                                      experienceDate: newImage.experienceDate ? newImage.experienceDate.S : '',
                                      experienceTime: newImage.experienceTime ? newImage.experienceTime.S : '',
                                      experienceDetails: newImage.experienceDetails ? newImage.experienceDetails.S : '',
                                      experienceRating: newImage.experienceRating ? newImage.experienceRating.S : '',
                                      experienceNotes: newImage.experienceNotes ? newImage.experienceNotes.S : ''
                                  };
                                  
                                  console.log('Sending status change notification');
                                  await sendLinkMessage(applicationData, 'status');
                              } else {
                                  console.log('Status not changed, skipping notification');
                              }
                          }
                      }
                  } else if (event.body) {
                      applicationData = JSON.parse(event.body);
                      await sendLinkMessage(applicationData);
                  }
          
                  return {
                      statusCode: 200,
                      body: JSON.stringify({
                          message: 'Notification sent successfully'
                      })
                  };
              } catch (error) {
                  console.error('Error processing event:', error);
                  return {
                      statusCode: 500,
                      body: JSON.stringify({
                          error: 'Failed to send notification',
                          message: error.message
                      })
                  };
              }
          };
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: ChildEnglishDemo

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${EnvironmentName}-api'
      Description: 'Child English Demo API'
      EndpointConfiguration:
        Types:
          - REGIONAL
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: ChildEnglishDemo

  # API Gateway Resource for Submit
  SubmitResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: 'submit'

  # API Gateway Resource for Admin
  AdminResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: 'admin'

  # API Gateway Resource for Admin Applications
  AdminApplicationsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref AdminResource
      PathPart: 'applications'

  # API Gateway Resource for Admin Applications by ID
  AdminApplicationsIdResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref AdminApplicationsResource
      PathPart: '{id}'

  # API Gateway Method for Submit POST
  SubmitPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref SubmitResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${FormSubmissionLambda.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  # API Gateway Method for Submit OPTIONS
  SubmitOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref SubmitResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${FormSubmissionLambda.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  # API Gateway Method for Admin GET
  AdminGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref AdminApplicationsResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AdminApiLambda.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  # API Gateway Method for Admin PUT
  AdminPutMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref AdminApplicationsIdResource
      HttpMethod: PUT
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AdminApiLambda.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  # API Gateway Method for Admin OPTIONS
  AdminOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref AdminApplicationsResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AdminApiLambda.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  # Lambda Permissions for API Gateway
  FormSubmissionLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref FormSubmissionLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  AdminApiLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AdminApiLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  # DynamoDB Streams Event Source Mapping
  BotNotificationEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt ApplicationsTable.StreamArn
      FunctionName: !GetAtt BotNotificationLambda.Arn
      StartingPosition: TRIM_HORIZON
      MaximumBatchingWindowInSeconds: 10

  # API Gateway Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - SubmitPostMethod
      - SubmitOptionsMethod
      - AdminGetMethod
      - AdminPutMethod
      - AdminOptionsMethod
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: prod
      Description: 'Production stage'

Outputs:
  ApiEndpoint:
    Description: 'API Gateway endpoint URL'
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Export:
      Name: !Sub '${EnvironmentName}-api-endpoint'

  DynamoDBTableName:
    Description: 'DynamoDB table name'
    Value: !Ref ApplicationsTable
    Export:
      Name: !Sub '${EnvironmentName}-table-name'

  DynamoDBTableArn:
    Description: 'DynamoDB table ARN'
    Value: !GetAtt ApplicationsTable.Arn
    Export:
      Name: !Sub '${EnvironmentName}-table-arn'

  FormSubmissionLambdaArn:
    Description: 'Form submission Lambda function ARN'
    Value: !GetAtt FormSubmissionLambda.Arn
    Export:
      Name: !Sub '${EnvironmentName}-form-lambda-arn'

  AdminApiLambdaArn:
    Description: 'Admin API Lambda function ARN'
    Value: !GetAtt AdminApiLambda.Arn
    Export:
      Name: !Sub '${EnvironmentName}-admin-lambda-arn'